import pygame
import pytmx
import sys
import os
from pytmx.util_pygame import load_pygame

sys.path.append(os.path.join(os.path.dirname(__file__), 'src'))
# Define the project root directory globally
project_root_dir =os.path.dirname(os.path.dirname(__file__))

from enemy import enemy_script
from enemy.unit.enemy import Enemy
from enemy.weapon.enemy_wpn import EnemyWeapon
from misc import *
from player.unit.player import Player
from.player.weapon.player_wpn import PlayerWeapon

# CONSTANTS
SPEED = 5  # the speed at which player moves
RESET_COOLDOWN = 10  # the global cooldown of player abilities (shooting weapons)
FPS = 60
FPS_CLOCK = pygame.time.Clock()
BLACK = pygame.Color(0, 0, 0)

current_dir = os.path.dirname(__file__)

def scroll_hitbox(surface, tiled_map, hitbox, scroll_x, debug=0):
    """ Add/update hitboxes after scrolling has taken place, using the tiled map as reference.
    This function is responsible for giving the walls and platforms a hitbox.

    Parameters:
        surface (pygame.Surface):       the game screen
        tiled_map (pytmx.TiledMap):     an object that represents a TMX file
        hitbox (pygame.sprite.Group):   group of all sprites that can be collided with player
        scroll_x (int): a value that represents how far the scrolling has taken place.
            the lesser the value, the farther.
        debug (int): if True, it will draw blue rectangles on all hitboxes generated by tiled map.
        
    """
    hitbox.empty()   # refresh hitbox sprites (due to scrolling)

    for layer in tiled_map.visible_layers:
        if isinstance(layer, pytmx.TiledObjectGroup):
            # iterate over all the objects in the layer
            for obj in layer:
                if debug:
                    spr = Block(
                        (obj.x + scroll_x, obj.y, obj.width, obj.height)
                    )
                    pygame.draw.rect(surface, (0, 0, 255),
                        (obj.x + scroll_x, obj.y, obj.width, obj.height))
                else:
                    spr = Block(
                        (obj.x + scroll_x, obj.y, obj.width, obj.height)
                    )

                hitbox.add(spr)  # add pytmx map platforms


def update_projectiles(surface, projectiles, hitbox, debug=0):
    """ Update the rectangle/animation of the projectiles in real-time and check for their collisions.

    Parameters:
        surface (pygame.Surface): the game screen
        projectiles (pygame.sprites.Group): group of all sprites that are projectiles
        hitbox (pygame.sprites.Group): group of all sprites that can be collided with player
        debug (int): if True, it will draw blue rectangles on all hitboxes generated by projectiles.
    """
    for projectile in projectiles:
        if projectile.charging:
            projectile.draw(surface)
        elif not projectile.charging and \
                len(pygame.sprite.spritecollide(projectile, hitbox, False, collision_projectile)) == 0 \
                and not projectile.out_of_screen and not projectile.dead:
            if isinstance(projectile, EnemyWeapon):
                hitbox.add(projectile)
            projectile.draw(surface)
            projectile.move()
            if debug:
                pygame.draw.rect(surface, (0, 0, 255),
                                 (projectile.rect.x,
                                  projectile.rect.y,
                                  projectile.image.get_width(),
                                  projectile.image.get_height()
                                  )
                                 )
        else:
            if not projectile.dead and isinstance(projectile, PlayerWeapon):
                projectile.impact(surface)
            else:
                projectiles.remove(projectile)


def collision_projectile(projectile, target):
    """ Collision handler for projectiles.

    Parameters:
        projectile (pygame.sprite): some random projectile (it may belong to the player or enemy)
        target (pygame.sprite): some random target (it may be the player or enemy).
            Since the player collision is handled elsewhere, we only really care about the target if it is an enemy.

    Returns:
        bool: if True, a collision has occurred. otherwise, no collision.
    """
    if pygame.sprite.collide_rect(projectile, target):
        # if the unit projectile hits the enemy...
        if isinstance(projectile, PlayerWeapon) and isinstance(target, Enemy):
            if target.invincible:
                return False
            else:
                target.take_damage(projectile.damage)

            projectile.draw_impact = False
            if projectile.damage < 13:  # weaker beams will not pierce through enemy kills (including mini beam)
                projectile.dead = True
            if target.dead:  # allows projectile to pass through after a kill
                return False

        # enemy projectiles shouldn't kill the enemy itself if they are touching
        elif isinstance(projectile, EnemyWeapon) and isinstance(target, Enemy):
            return False

        # unit projectiles and enemy projectiles should pass through each other
        elif isinstance(projectile, PlayerWeapon) and isinstance(target, EnemyWeapon):
            return False

        # same goes for enemy projectiles and other enemy projectiles!
        elif isinstance(projectile, EnemyWeapon) and isinstance(target, EnemyWeapon):
            return False

        projectile.collide_distance = target.rect.x - projectile.rect.x
        return True
    else:
        return False


def player_handler(surface, player, hitbox, scroll):
    """ Collision handler for the player. Handles player death by collision and also prevention of overlapping walls.

    Parameters:
        surface (pygame.Surface): the game screen
        player (pygame.sprite): the player unit sprite
        hitbox (pygame.sprites.Group): group of all sprites that can be collided with player
        scroll (bool): If True, then the screen is in scrolling mode. Otherwise, the screen is fixed in position.

    """
    if len(pygame.sprite.spritecollide(player, hitbox, False, pygame.sprite.collide_mask)) > 0:
        if not player.invincible:
            player.death()
        else:
            if scroll:
                player.rect.x = player.last_pos[0] - 1  # offset to compensate for automatic right-scrolling screen
            else:
                player.rect.x = player.last_pos[0]
            player.rect.y = player.last_pos[1]


def enemy_handler(surface, player, enemies, hitbox, scroll):
    """ Handles enemy movements on surface, giving them rectangle blocks, drawing them, deleting them, etc.

    Parameters:
        surface (pygame.Surface): the game screen
        player (pygame.sprite): the player unit sprite
        enemies (pygame.sprite.Group): group of all enemy sprites
        hitbox (pygame.sprites.Group): group of all sprites that can be collided with player
        scroll (bool): True if the screen is scrolling, False if the screen is paused and fixed.
    """
    for enemy in enemies:
        if scroll:
            enemy.move(-1, 0)  # compensation for scrolling screen
        if enemy.dead_counter == 0:
            hitbox.add(enemy)

        if player.rect.x - enemy.rect.x > surface.get_width():  # if unit has passed enemy far enough, kill enemy
            enemy.death(sound=False)  # start dead_counter on enemy

        if enemy.dead_counter < enemy.dead_counter_max:
            enemy.draw(surface)
        else:
            enemies.remove(enemy)


def player_keys_move(surface, player, keys):
    """ Handles player keys for movement (i.e. W, A, S, D keys)

    Parameters:
        surface (pygame.Surface): the game screen
        player (pygame.sprite): the player unit sprite
        keys (pygame.key.get_pressed()): all the keys that are currently pressed

    """
    vx, vy = 0, 0
    player.last_pos = (player.rect.x, player.rect.y)

    if keys[pygame.K_w]:
        vy -= SPEED
    elif keys[pygame.K_s]:
        vy += SPEED

    if keys[pygame.K_a]:
        vx -= SPEED
    elif keys[pygame.K_d]:
        vx += SPEED

    player.move(surface, vx, vy)


def player_keys_shoot(surface, player, keys, projectiles, cooldown_counter):
    """

    Parameters:
        surface (pygame.Surface): the game screen
        player (pygame.sprite): the player unit sprite
        keys (pygame.key.get_pressed()): all the keys that are currently pressed
        projectiles (pygame.sprites.Group): group of all sprites that are projectiles
        cooldown_counter (int): a counter that keeps track of attack cooldown state (i.e. no-attack state)

    Returns:
        int : the cooldown counter after incrementation, or 0
    """
    if keys[pygame.K_SPACE] and not player.charged_beam:
        if cooldown_counter == 0 and not player.dead:
            projectiles.add(
                player.shoot(player.rect.x+player.image.get_width(), player.rect.y+player.image.get_height()/2)
            )
            cooldown_counter += 1  # Initiate cooldown sequence
    elif keys[pygame.K_e]:
        if not player.charged_beam and not player.dead:
            projectiles.add(
                player.shoot(player.rect.x+player.image.get_width()-5, player.rect.y+player.image.get_height()/2, True)
            )
    else:
        if player.charged_beam:
            player.charged_beam.charging = False  # reset charge if no keys are pressed
        player.charged_beam = None  # delete charged beam

    if cooldown_counter == RESET_COOLDOWN:
        cooldown_counter = 0
    elif cooldown_counter > 0:
        cooldown_counter += 1
    return cooldown_counter



def start_level(surface):
    surface.fill((0, 0, 0))  # Wipe the screen
    bg = load_image("img/stage.png")
    ready_logo = load_image("img/ready.gif")
    game_over_logo = load_image("img/game_over.gif")

    setup_music('sounds/music/solo_sortie.mp3')
    victory_tune = pygame.mixer.Sound(os.path.join(project_root_dir, 'sounds/victory.wav'))

    hitbox, projectiles, player = initialize_sprites(surface)

    lives, scroll, scroll_x = 3, True, 0
    game_start, game_pause, boss_pause, player_lock = True, False, False, False
    boss_timer, boss_pause_timer, win_pause_timer = 0, 0, 0
    round_clear, play_win_theme = False, False

    enemies = enemy_script.create_enemies(surface, scroll_x)

    cooldown_counter, rf_counter = 0, 250
    tiled_map = load_pygame(os.path.join(project_root_dir, 'tilemap/rtype_tile.tmx'))

    alpha_surface, alpha = create_alpha_surface()
    alpha = 0  # Initialize alpha

    while True:  # Main game loop
        handle_events(player, game_pause, boss_pause_timer)

        if not game_start and not game_pause:
            handle_key_events(surface, player, projectiles, cooldown_counter, bg, scroll_x, hitbox, tiled_map)
            handle_collisions(surface, player, enemies, hitbox, projectiles, scroll)
            draw_ui(surface, lives)

        if player.dead or game_start:
            rf_counter, alpha = start_round(surface, rf_counter, alpha_surface, ready_logo, game_over_logo, player, lives, game_start, projectiles, alpha)
            if rf_counter == 0 and lives == 0:
                return

        manage_scrolling(bg, scroll_x, surface, alpha_surface, alpha, round_clear, boss_timer, boss_pause_timer, enemies, player, victory_tune, play_win_theme, game_start, game_pause)

        pygame.display.update()
        FPS_CLOCK.tick(FPS)

def create_alpha_surface():
    alpha_surface = pygame.Surface((800, 600))
    alpha_surface.fill((0, 0, 0))
    alpha = 245
    alpha_surface.set_alpha(alpha)
    return 

def load_image(path):
    image_path = os.path.join(project_root_dir, path)
    return pygame.image.load(image_path).convert()

def setup_music(path):
    music_path = os.path.join(project_root_dir, path)
    pygame.mixer.music.load(music_path)
    pygame.mixer.music.play(-1, 0.2)

def initialize_sprites(surface):
    hitbox = pygame.sprite.Group()
    projectiles = pygame.sprite.Group()
    player = Player(100, 280)
    player.draw(surface)
    return hitbox, projectiles, player

def create_alpha_surface():
    alpha_surface = pygame.Surface((800, 600))
    alpha_surface.fill((0, 0, 0))
    alpha = 245
    alpha_surface.set_alpha(alpha)
    return alpha_surface, alpha

def handle_events(player, game_pause, boss_pause_timer):
    for event in pygame.event.get():
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_RETURN:
                game_pause = not game_pause
                pygame.mixer.Sound(os.path.join(project_root_dir, 'sounds/start.ogg')).play()

def handle_key_events(surface, player, projectiles, cooldown_counter, bg, scroll_x, hitbox, tiled_map):
    keys = pygame.key.get_pressed()
    player_keys_move(surface, player, keys)
    cooldown_counter = player_keys_shoot(surface, player, keys, projectiles, cooldown_counter)
    surface.blit(bg, (scroll_x, 0))  # SCROLL the background in +x direction
    scroll_hitbox(surface, tiled_map, hitbox, scroll_x)

def handle_collisions(surface, player, enemies, hitbox, projectiles, scroll):
    enemy_handler(surface, player, enemies, hitbox, scroll)
    update_projectiles(surface, projectiles, hitbox)
    player.draw(surface)
    player_handler(surface, player, hitbox, scroll)

def draw_ui(surface, lives):
    pygame.draw.rect(surface, BLACK, (0, 560, 800, 40))
    for i in range(lives):
        lives_ico = Icon(100 + (i * 30), 565)
        lives_ico.draw(surface)

def start_round(surface, rf_counter, alpha_surface, ready_logo, game_over_logo, player, lives, game_start, projectiles, alpha):
    pygame.mixer.music.stop()
    rf_counter += 1

    if 250 > rf_counter > 200:
        alpha = fade_out(alpha_surface, alpha)
    elif 300 > rf_counter > 250:
        reset_round(surface, alpha_surface, ready_logo, game_over_logo, player, lives, game_start, projectiles)
        rf_counter = 300
    elif 400 > rf_counter > 350 and lives > 0:
        alpha_surface.fill((0, 0, 0))
        alpha = fade_in(alpha_surface, alpha)
    elif rf_counter >= 400 and lives > 0:
        setup_music('sounds/music/solo_sortie.mp3')
        player.respawn()
        rf_counter = 0
        game_start = False
    elif 600 > rf_counter > 500 and lives == 0:
        alpha_surface.fill((0, 0, 0))
    elif rf_counter > 600 and lives == 0:
        return 0, 0

    surface.blit(alpha_surface, (0, 0))
    return rf_counter, alpha

def fade_out(alpha_surface, alpha):
    alpha += 6
    alpha_surface.set_alpha(alpha)
    return alpha

def fade_in(alpha_surface, alpha):
    alpha -= 6
    alpha_surface.set_alpha(alpha)
    return alpha
    


def reset_round(surface, alpha_surface, ready_logo, game_over_logo, player, lives, game_start, projectiles):
    scroll_x = 0
    scroll = True
    boss_timer = 0
    if not game_start:
        lives -= 1
    if lives == 0:
        alpha_surface.blit(game_over_logo, (surface.get_width() / 2 - game_over_logo.get_width() / 2, surface.get_height() / 2 - game_over_logo.get_height() / 2))
    else:
        alpha_surface.blit(ready_logo, (surface.get_width() / 2 - ready_logo.get_width() / 2, surface.get_height() / 2 - ready_logo.get_height() / 2))
    enemies = enemy_script.create_enemies(surface, scroll_x)
    projectiles.empty()


def manage_scrolling(bg, scroll_x, surface, alpha_surface, alpha, round_clear, boss_timer, boss_pause_timer, enemies, player, victory_tune, play_win_theme, game_start, game_pause):
    if not game_start and not game_pause and scroll_x > -5800:
        scroll_x -= 1
    elif -5850 < scroll_x <= -5800:
        pygame.mixer.music.fadeout(1000)
        scroll_x -= 1
    elif scroll_x <= -5850:
        handle_boss_fight(bg, scroll_x, surface, alpha_surface, round_clear, boss_timer, boss_pause_timer, enemies, player, victory_tune, play_win_theme)
    else:
        if not round_clear:
            alpha = 0


def handle_boss_fight(bg, scroll_x, surface, alpha_surface, round_clear, boss_timer, boss_pause_timer, enemies, player, victory_tune, play_win_theme):
    if scroll:
        setup_music('sounds/music/boss.mp3')
        scroll = False
        boss_pause_timer = 4000 + pygame.time.get_ticks()
        player_lock = True
    if pygame.time.get_ticks() >= boss_pause_timer:
        if player_lock:
            player_lock = False
        if not game_pause:
            boss_timer += 1
            if boss_timer > 300:
                boss_timer = 1
    if not round_clear and not game_pause:
        round_clear = enemy_script.load(scroll_x, boss_timer, player, enemies, projectiles)
    if round_clear:
        if not play_win_theme:
            player.be_invincible(animation=False)
            play_win_theme = True
            pygame.time.wait(1000)
            victory_tune.play()
            boss_pause_timer = 6000 + pygame.time.get_ticks()
            alpha_surface.blit(game_over_logo, (surface.get_width() / 2 - game_over_logo.get_width() / 2, surface.get_height() / 2 - game_over_logo.get_height() / 2))
        if pygame.time.get_ticks() >= boss_pause_timer:
            alpha += 2
            alpha_surface.set_alpha(alpha)
            surface.blit(alpha_surface, (0, 0))
            if alpha > 800:
                return